# 阶段 4: 架构设计 (Architecture Design)

## 🎯 目标

设计详细的实施方案,包括数据库设计、API 端点设计、服务层架构和详细的实施步骤。

---

## 阶段标记

**开始时输出**:
```markdown
---
## 🚀 当前阶段:4 - 架构设计
---
```

**结束时输出**(用户确认后):
```markdown
---
✅ 阶段 4 完成

📍 下一阶段:5 - 实施
---
```

---

## MCP 工具使用

### 📚 优先尝试:context7.query-docs
**目的**:获取框架的架构指南
**降级方案**:WebSearch

### 🔍 优先尝试:exa.web_search_exa
**目的**:搜索架构模式和设计最佳实践
**降级方案**:WebSearch

---

## 必须使用: code-architect Agent

**Phase 4 核心步骤**: 根据需求复杂度选择合适的架构设计模式。

---

## ⚠️ 复杂度判断和模式选择

### 判断需求复杂度

#### 简单/中等需求（使用单方案模式）
- 单一功能或涉及 2-3 个模块
- 实现路径清晰明确
- 不涉及重大架构变更
- 示例：添加字段、CRUD操作、简单业务流程

#### 复杂需求（使用多方案模式）
满足以下**任一**条件：
- ✅ 有**多种明显不同的实现路径**（技术方案差异大）
- ✅ 存在**重大架构权衡**（性能vs复杂度、时间vs质量、可扩展性vs简洁性）
- ✅ **影响多个核心模块**（3个以上模块需要重大修改）
- ✅ **引入新的技术或架构模式**（新框架、新设计模式）
- ✅ **用户明确要求**对比多个方案

---

## 模式 1: 单方案设计（简单/中等需求）

### 执行步骤

**步骤 1: 主进程使用 ultrathink 进行深度分析**

调用 **mcp__sequential-thinking__sequentialthinking 工具**：

```markdown
使用 sequential-thinking 工具分析：
1. 分解需求组件和依赖关系
2. 分析可能的实现路径
3. 做出关键架构决策（基于项目约定和最佳实践）
4. 识别主要风险和权衡点
5. 确定推荐的架构方向
```

**步骤 2: 启动单个 code-architect agent 细化设计**

使用结构化上下文模板传递信息：

```markdown
Task: 细化架构设计
- description: "基于 ultrathink 分析细化架构设计"
- prompt: "## 任务
基于以下 ultrathink 深度分析结果，细化架构设计并产出详细的实施蓝图

## Ultrathink 分析结果
${将 sequential-thinking 的分析结果完整列出：
- 需求组件分解
- 关键架构决策及理由
- 推荐的实现路径
- 识别的风险和权衡点}

---

## 完整上下文

### 1. 需求理解 (阶段 1 结果)

#### 核心功能
${将阶段 1 识别的核心功能完整列出}

#### 业务实体
${将阶段 1 识别的业务实体和字段需求完整列出}

#### API 端点需求
${将阶段 1 识别的 API 端点需求完整列出}

#### 业务规则
${将阶段 1 识别的业务规则和约束完整列出}

#### 集成点
${将阶段 1 识别的集成点和依赖完整列出}

---

### 2. 代码库探索发现 (阶段 2 结果)

#### CLAUDE.md 规范要点
${如果有 CLAUDE.md,列出关键规范:}
- 编码规范: [命名约定、代码风格等]
- API 设计规范: [路由命名、请求/响应格式等]
- 数据库设计规范: [表命名、字段类型、索引规范等]
- 架构模式: [项目采用的架构模式]
- 错误处理规范: [错误码、异常处理方式等]

#### 项目架构和技术栈
- 架构风格: [MVC/分层架构/微服务/单体等]
- 编程语言: [使用的语言和版本]
- 主要框架: [Web框架、ORM等]
- 数据库: [数据库类型和版本]
- 关键依赖: [重要的第三方库]

#### 相关现有实现
${列出 code-explorer 发现的相关组件:}
- 数据层: [相关实体、Repository 示例]
- 服务层: [相关服务、业务逻辑模式]
- API 层: [相关控制器、路由模式]
- 通用工具: [可复用的工具类、辅助函数]

#### 设计模式和代码风格
${列出项目中使用的设计模式和约定:}
- 常用设计模式: [Repository、Factory、Singleton 等]
- 错误处理模式: [统一错误处理方式]
- 数据验证模式: [验证规则的实现方式]
- 事务管理模式: [事务处理的常见做法]

#### 必读架构参考文件
${列出 code-explorer 识别的 5-10 个关键文件路径}

---

### 3. 用户澄清和决策 (阶段 3 结果)

${如果阶段 3 使用了 AskUserQuestion,列出所有问题和用户的回答:}

#### 澄清的问题 1
**问题**: [原始问题]
**用户回答**: [用户的选择和说明]
**影响**: [这个决策如何影响架构设计]

${如果没有澄清问题,说明: 无需澄清 - 需求已经明确}

---

### 4. 外部资源研究 (如适用)

${如果阶段 2.5 进行了外部资源研究,列出关键发现}

---

## 细化设计要求

基于 ultrathink 的分析和以上完整上下文,请细化架构设计：

1. **探索代码库**
   - 使用 Glob、Grep、Read 工具深入探索相关代码
   - 找到类似功能的实现细节
   - 理解项目的具体实现模式

2. **数据库设计**
   - 实体定义(字段、类型、约束)
   - 表之间的关联关系
   - 索引设计
   - 符合 CLAUDE.md 中的数据库设计规范

3. **API 端点设计**
   - REST 端点定义(方法、路径)
   - 请求/响应结构
   - 认证和授权要求
   - 符合 CLAUDE.md 中的 API 设计规范

4. **服务层架构**
   - 服务接口定义
   - 业务逻辑流程
   - 依赖关系和注入
   - 事务管理策略
   - 符合 CLAUDE.md 中的架构模式

5. **风险分析**
   - 验证 ultrathink 识别的风险
   - 补充技术实现层面的风险

6. **详细实施步骤**
   - 至少 5-10 个详细步骤
   - 每步包含: 任务、产出、验证方式
   - 按依赖关系排序

7. **关键架构参考文件**
   - 返回 5-10 个必读的架构参考文件路径"

- subagent_type: "spec-dev:code-architect"
- model: "sonnet"
- run_in_background: false  # 阻塞等待,因为只有一个 agent
```

**步骤 3: 向用户展示方案**

展示单一的最佳方案，包含：
- Ultrathink 的深度分析结果
- Code-architect 的详细设计
- 完整的实施步骤

---

## 模式 2: 多方案设计（复杂需求）

### 执行步骤

**步骤 1: 并行启动 2-3 个 code-architect agents**

⚠️ **不使用主进程 ultrathink**（agents 会各自进行深度分析）

**⚠️ 关键改进: 使用结构化上下文模板**

为确保每个 code-architect 获得完整准确的上下文,使用以下结构化模板：

**⚠️ 并行执行要求**：
- **必须在单个消息中**发起 2-3 个 Task 工具调用
- **每个 Task 必须设置** `run_in_background: true`
- **然后使用 TaskOutput** 收集每个 agent 的结果

**Agent 方案分工**：
- Agent 1: 最小改动方案 - 快速交付，最小化风险
- Agent 2: 清晰架构方案 - 追求最佳实践和长期可维护性
- Agent 3: 实用平衡方案 - 在速度和质量之间找平衡（通常推荐）

**并行调用模板**：

```markdown
Task 1/2/3: 设计[方案类型]架构方案
- description: "设计[最小改动/清晰架构/实用平衡]方案"
- prompt: "## 任务
为 [功能名称] 设计详细的架构蓝图

⚠️ 要求：
1. 进行系统化的深度分析和架构设计
2. 设计方案类型: **[最小改动/清晰架构/实用平衡]方案**
3. 提供详细的架构决策理由和权衡分析

---

## 完整上下文

### 1. 需求理解 (阶段 1 结果)

#### 核心功能
${将阶段 1 识别的核心功能完整列出}

#### 业务实体
${将阶段 1 识别的业务实体和字段需求完整列出}

#### API 端点需求
${将阶段 1 识别的 API 端点需求完整列出}

#### 业务规则
${将阶段 1 识别的业务规则和约束完整列出}

#### 集成点
${将阶段 1 识别的集成点和依赖完整列出}

---

### 2. 代码库探索发现 (阶段 2 结果)

#### CLAUDE.md 规范要点
${如果有 CLAUDE.md,列出关键规范:}
- 编码规范: [命名约定、代码风格等]
- API 设计规范: [路由命名、请求/响应格式等]
- 数据库设计规范: [表命名、字段类型、索引规范等]
- 架构模式: [项目采用的架构模式]
- 错误处理规范: [错误码、异常处理方式等]

#### 项目架构和技术栈
- 架构风格: [MVC/分层架构/微服务/单体等]
- 编程语言: [使用的语言和版本]
- 主要框架: [Web框架、ORM等]
- 数据库: [数据库类型和版本]
- 关键依赖: [重要的第三方库]

#### 相关现有实现
${列出 code-explorer 发现的相关组件:}
- 数据层: [相关实体、Repository 示例]
- 服务层: [相关服务、业务逻辑模式]
- API 层: [相关控制器、路由模式]
- 通用工具: [可复用的工具类、辅助函数]

#### 设计模式和代码风格
${列出项目中使用的设计模式和约定:}
- 常用设计模式: [Repository、Factory、Singleton 等]
- 错误处理模式: [统一错误处理方式]
- 数据验证模式: [验证规则的实现方式]
- 事务管理模式: [事务处理的常见做法]

#### 必读架构参考文件
${列出 code-explorer 识别的 5-10 个关键文件路径,供主进程阅读}

---

### 3. 用户澄清和决策 (阶段 3 结果)

${如果阶段 3 使用了 AskUserQuestion,列出所有问题和用户的回答:}

#### 澄清的问题 1
**问题**: [原始问题]
**用户回答**: [用户的选择和说明]
**影响**: [这个决策如何影响架构设计]

#### 澄清的问题 2
[重复上述结构]

${如果没有澄清问题,说明: 无需澄清 - 需求已经明确}

---

### 4. 外部资源研究 (如适用)

${如果阶段 2.5 进行了外部资源研究,列出关键发现:}

#### 相关库文档和 API
[从 context7 或 WebSearch 获取的库文档要点]

#### 最佳实践和代码示例
[从 exa 或 WebSearch 获取的最佳实践]

${如果没有进行外部资源研究,省略此部分}

---

## 设计要求

基于以上完整上下文,请设计 **[方案类型]方案**:

1. **数据库设计**
   - 实体定义(字段、类型、约束)
   - 表之间的关联关系
   - 索引设计
   - 符合 CLAUDE.md 中的数据库设计规范

2. **API 端点设计**
   - REST 端点定义(方法、路径)
   - 请求/响应结构
   - 认证和授权要求
   - 符合 CLAUDE.md 中的 API 设计规范

3. **服务层架构**
   - 服务接口定义
   - 业务逻辑流程
   - 依赖关系和注入
   - 事务管理策略
   - 符合 CLAUDE.md 中的架构模式

4. **风险分析**
   - 识别潜在的架构风险
   - 分析边缘情况
   - 性能考虑
   - 安全问题

5. **详细实施步骤**
   - 至少 5-10 个详细步骤
   - 每步包含: 任务、产出、验证方式
   - 按依赖关系排序

6. **关键架构参考文件**
   - 返回 5-10 个必读的架构参考文件路径

7. **方案优劣势分析**
   - 本方案的优势
   - 本方案的劣势和权衡
   - 与其他方案的对比(如适用)"

- subagent_type: "spec-dev:code-architect"
- model: "sonnet"
- run_in_background: true
```

**步骤 2: 读取 agents 推荐的架构文件**

主进程阅读每个 agent 识别的 5-10 个关键架构参考文件，理解现有架构模式。

**步骤 3: 整合方案并向用户展示**

展示多方案对比：

```markdown
## 🎯 架构方案设计

### 方案对比表格

| 维度 | 方案 A（最小改动） | 方案 B（清晰架构） | 方案 C（实用平衡）⭐ |
|------|-------|-------|---------|
| 开发时间 | 短 | 长 | 中 |
| 代码质量 | 一般 | 优秀 | 良好 |
| 可维护性 | 中等 | 高 | 较高 |
| 扩展性 | 低 | 高 | 中 |
| 风险 | 低 | 中 | 低-中 |

### 方案 A：最小改动
[详细设计内容]

### 方案 B：清晰架构
[详细设计内容]

### 方案 C：实用平衡（推荐）
[详细设计内容]

### 推荐意见
[基于权衡分析给出推荐方案及理由]

**你希望使用哪个方案？**
```

---

## Agent 输出要求

（适用于两种模式）

1. 关键架构文件清单(5-10 个)
2. 完整架构设计(数据库、API、服务层)
3. 架构模式和最佳实践
4. 风险分析
5. 详细实施步骤
6. 方案优劣势分析（多方案模式）

---

## 设计产出

### 1. 数据库设计

**实体定义示例**:

```
Entity: Dashboard
├─ 字段:
│  ├─ id: 主键,自增整数
│  ├─ user_id: 外键,整数,非空,索引
│  ├─ name: 字符串,最大 100,非空
│  └─ created_at: 时间戳
├─ 索引:
│  └─ idx_user_id: (user_id)
└─ 关联:
   └─ User: 多对一(belongs_to)
```

### 2. API 端点设计

```
| 方法 | 路径 | 描述 | 认证 |
|------|------|------|------|
| GET | /api/dashboards | 获取列表 | 必须 |
| POST | /api/dashboards | 创建 | 必须 |
| PUT | /api/dashboards/:id | 更新 | 必须 |
```

**请求/响应结构**:

```
POST /api/dashboards
Request: { "name": string, "description": string }
Response (201): { "id": integer, "name": string, ... }
Error (400/401): { "error": string, "message": string }
```

### 3. 服务层设计

```
Service: DashboardService
Methods:
├─ create(userId, request) → Dashboard
├─ getById(id, userId) → Dashboard
├─ list(userId) → Dashboard[]
└─ update(id, userId, request) → Dashboard

Dependencies:
├─ database: DatabaseConnection
└─ repository: DashboardRepository
```

### 4. 实施步骤

**⚠️ 必须产出**,至少 5-10 个步骤:

```markdown
## 实施步骤

### 步骤 1: 创建实体和数据库schema
**任务**: 创建 Dashboard 实体、数据库迁移文件
**产出**: 实体文件、迁移文件
**验证**: 运行迁移,确认表创建成功

### 步骤 2: 实施数据访问层
**任务**: 创建 Repository,实现 CRUD 方法
**产出**: Repository 文件、基础方法
**验证**: 单元测试通过

[... 继续其他步骤 ...]
```

---

## ⚠️ 等待用户确认(CRITICAL CHECKPOINT)

### 关键规则

**MUST DO**:
1. ✅ 完成架构设计
2. ✅ 向用户展示方案
3. ✅ 明确请求确认:"**我可以开始实施了吗?**"
4. ✅ 等待用户明确回复("确认"、"可以"、"开始"等)
5. ✅ 收到确认后输出阶段完成标记

**ABSOLUTELY PROHIBITED**:
- ❌ 未确认前开始实施
- ❌ 假设用户默认同意
- ❌ 跳过确认步骤

### 确认请求格式

```markdown
## ✅ 准备好实施了吗?

我已经设计了完整的架构方案:

✓ 数据库设计(X 个实体)
✓ API 端点设计(X 个端点)
✓ 服务层设计(X 个服务)
✓ 详细的实施步骤(X 步)

**我可以开始实施了吗?**
```

### 等待用户回应

**⚠️ THIS IS A HARD STOP - DO NOT PROCEED WITHOUT CONFIRMATION**

**必须做**:
- ✅ STOP - 停止所有操作
- ✅ WAIT - 等待用户明确回应
- ✅ 确认后输出阶段完成标记

**绝对禁止**:
- ❌ 确认前开始实施
- ❌ 假设默认同意
- ❌ 跳过确认步骤

### 处理用户反馈

**场景 1:用户明确确认**

```markdown
---
📥 已收到用户确认

✅ 阶段 4 完成

📍 下一阶段:5 - 实施
---
```

**场景 2:用户要求修改**

```markdown
---
📥 已收到用户反馈

⚠️ 继续阶段 4 - 架构设计(更新设计)
---
```

**场景 3:用户回复不明确**

再次请求确认:"**那我可以开始实施了吗?**"

---

## 进入下一阶段

用户确认架构方案后,进入 **阶段 5: 实施**。
